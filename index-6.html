<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Texas Precinct Dashboard (SVG)</title>
  <style>
    :root{
      --bg:#0b1220;
      --panel:#0f1a2f;
      --panel2:#0c1528;
      --text:#e8eefc;
      --muted:#b5c0dc;
      --border:rgba(255,255,255,.10);
      --accent:#86a8ff;
      --danger:#ff6b6b;
      --ok:#7ef0b3;
    }
    html,body{height:100%; margin:0; background:var(--bg); color:var(--text); font-family:ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;}
    .app{display:grid; grid-template-columns: 360px 1fr; height:100%;}
    .sidebar{background:linear-gradient(180deg,var(--panel),var(--panel2)); border-right:1px solid var(--border); padding:14px 14px 16px; overflow:auto;}
    .mapwrap{position:relative; overflow:hidden;}
    #mapHost{position:absolute; inset:0; display:flex; align-items:center; justify-content:center;}
    .title{font-weight:700; letter-spacing:.2px; font-size:16px; margin:0 0 8px;}
    .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap;}
    .card{border:1px solid var(--border); border-radius:12px; padding:10px; background:rgba(255,255,255,.03); margin:10px 0;}
    label{font-size:12px; color:var(--muted); display:block; margin:8px 0 4px;}
    select, button{
      width:100%;
      border:1px solid var(--border);
      background:rgba(255,255,255,.04);
      color:var(--text);
      border-radius:10px;
      padding:8px 10px;
      font-size:13px;
      outline:none;
    }
    select:focus, button:focus{border-color:rgba(134,168,255,.45); box-shadow:0 0 0 3px rgba(134,168,255,.12);}
    button{cursor:pointer; user-select:none;}
    button.secondary{background:rgba(255,255,255,.02);}
    .tabs{display:grid; grid-template-columns:1fr 1fr; gap:8px; margin:8px 0 2px;}
    .tab{padding:8px 10px; border-radius:10px; border:1px solid var(--border); background:rgba(255,255,255,.03); font-size:13px; cursor:pointer;}
    .tab.active{border-color:rgba(134,168,255,.55); background:rgba(134,168,255,.10);}
    .subtabs{display:grid; grid-template-columns:1fr 1fr; gap:8px; margin-top:8px;}
    .hint{font-size:12px; color:var(--muted); line-height:1.35; margin-top:8px;}
    .kv{font-size:12px; color:var(--muted); display:grid; grid-template-columns: 1fr auto; gap:6px 10px; margin-top:8px;}
    .kv b{color:var(--text); font-weight:650;}
    .legend{margin-top:10px;}
    .legendbar{height:14px; border-radius:999px; border:1px solid var(--border); overflow:hidden; background:rgba(255,255,255,.02);}
    .legendticks{display:flex; justify-content:space-between; font-size:11px; color:var(--muted); margin-top:6px;}
    .status{font-size:12px; color:var(--muted);}
    .status .ok{color:var(--ok);}
    .status .bad{color:var(--danger);}
    /* Loading overlay */
    #overlay{
      position:absolute; inset:0;
      background:rgba(7,11,18,.76);
      backdrop-filter: blur(4px);
      display:flex; align-items:center; justify-content:center;
      z-index:20;
    }
    #overlay .box{
      width:min(520px, 92vw);
      border:1px solid var(--border);
      border-radius:14px;
      background:rgba(15,26,47,.92);
      padding:14px 14px 12px;
    }
    #overlay .line1{font-weight:700; margin:0 0 6px; font-size:14px;}
    #overlay .line2{margin:0; font-size:12px; color:var(--muted); white-space:pre-wrap;}
    #overlay .btnrow{display:flex; gap:10px; margin-top:10px;}
    #overlay button{width:auto; padding:8px 12px; border-radius:10px;}
    /* Tooltip */
    #tip{
      position:absolute;
      z-index:15;
      pointer-events:none;
      transform: translate(10px,10px);
      min-width: 220px;
      max-width: 340px;
      border:1px solid var(--border);
      border-radius:12px;
      background:rgba(15,26,47,.95);
      padding:10px;
      box-shadow: 0 12px 40px rgba(0,0,0,.35);
      opacity:0;
      transition: opacity .08s linear;
    }
    #tip.show{opacity:1;}
    #tip .h{font-weight:700; font-size:13px; margin:0 0 6px;}
    #tip .p{margin:0; color:var(--muted); font-size:12px; line-height:1.35;}
    #tip .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;}
    /* SVG styling */
    #txsvg path{
      fill:#223554;
      stroke: rgba(255,255,255,.16);
      stroke-width: .30;
      vector-effect: non-scaling-stroke;
      paint-order: stroke fill;
      stroke-linejoin: round;
      stroke-linecap: round;
      cursor: pointer;
    }
    #txsvg path.miss{fill:#0e1728;}
    #txsvg path.hover{
      stroke: rgba(255,255,255,.95);
      stroke-width: .85;
    }
    /* Small */
    .mini{font-size:11px; color:var(--muted); margin-top:6px;}
    .pill{display:inline-block; padding:2px 8px; border:1px solid var(--border); border-radius:999px; font-size:11px; color:var(--muted);}
  </style>

  <!-- Libraries -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/svg-pan-zoom@3.6.1/dist/svg-pan-zoom.min.js"></script>
</head>

<body>
  <div class="app">
    <aside class="sidebar">
      <h1 class="title">Texas Precinct Dashboard</h1>

      <div class="card">
        <div class="tabs">
          <div class="tab active" data-tab="results">Election results</div>
          <div class="tab" data-tab="swing">Election swing</div>
        </div>
        <div class="tabs" style="margin-top:8px;">
          <div class="tab" data-tab="trend">Trend index</div>
          <div class="tab" data-tab="trendChange">Trend change</div>
        </div>

        <label>Data file</label>
        <select id="dataFile"></select>
        <div class="mini">Best: <span class="mono">precinct-data-pctkey.csv</span> (must include <span class="mono">PCTKEY</span>).</div>

        <div id="panelResults" class="panel">
          <label>Contest</label>
          <select id="contest"></select>
        </div>

        <div id="panelSwing" class="panel" style="display:none;">
          <label>From</label>
          <select id="swingFrom"></select>
          <label>To</label>
          <select id="swingTo"></select>
        </div>

        <div id="panelTrend" class="panel" style="display:none;">
          <label>Contest</label>
          <select id="trendContest"></select>
          <label>Party</label>
          <select id="trendParty">
            <option value="D">Dem</option>
            <option value="R">Rep</option>
          </select>
        </div>

        <div id="panelTrendChange" class="panel" style="display:none;">
          <label>From</label>
          <select id="trendFrom"></select>
          <label>To</label>
          <select id="trendTo"></select>
          <label>Party</label>
          <select id="trendChangeParty">
            <option value="D">Dem</option>
            <option value="R">Rep</option>
          </select>
        </div>

        <div class="subtabs">
          <button id="fitBtn" class="secondary">Fit</button>
          <button id="resetBtn" class="secondary">Reset zoom</button>
        </div>

        <div class="legend">
          <div class="pill" id="legendTitle">Margin</div>
          <div class="legendbar" id="legendBar"></div>
          <div class="legendticks" id="legendTicks"></div>
        </div>

        <div class="hint">
          Click a precinct for details. Hover highlights. If you open this via <span class="mono">file://</span>, fetch() will fail—serve it (GitHub Pages or a local server).
        </div>

        <div class="kv" id="stats">
          <div>SVG paths</div><b id="statPaths">–</b>
          <div>Data rows</div><b id="statRows">–</b>
          <div>Matched</div><b id="statMatched">–</b>
          <div>Unmatched</div><b id="statUnmatched">–</b>
        </div>

        <div class="status" id="status">Status: <span class="ok">ready</span></div>
      </div>
    </aside>

    <main class="mapwrap">
      <div id="mapHost"></div>
      <div id="tip"></div>

      <div id="overlay" style="display:none;">
        <div class="box">
          <p class="line1" id="ovTitle">Loading…</p>
          <p class="line2" id="ovMsg">Starting…</p>
          <div class="btnrow">
            <button id="ovClose" class="secondary" style="display:none;">Close</button>
            <button id="ovReload" class="secondary" style="display:none;">Reload</button>
          </div>
        </div>
      </div>
    </main>
  </div>

<script>
(() => {
  "use strict";

  // ---------- Utilities ----------
  const $ = (sel) => document.querySelector(sel);
  const overlay = $("#overlay");
  const ovTitle = $("#ovTitle");
  const ovMsg = $("#ovMsg");
  const ovClose = $("#ovClose");
  const ovReload = $("#ovReload");

  function showOverlay(title, msg, {closable=false, reload=false} = {}) {
    ovTitle.textContent = title;
    ovMsg.textContent = msg;
    overlay.style.display = "flex";
    ovClose.style.display = closable ? "inline-block" : "none";
    ovReload.style.display = reload ? "inline-block" : "none";
  }
  function hideOverlay(){ overlay.style.display = "none"; }
  function nextFrame(){ return new Promise(r => requestAnimationFrame(() => r())); }

  function setStatus(text, ok=true){
    $("#status").innerHTML = `Status: <span class="${ok ? "ok":"bad"}">${escapeHtml(text)}</span>`;
  }
  function escapeHtml(s){
    return String(s).replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;").replaceAll('"',"&quot;");
  }

  function clamp(x,a,b){ return x<a?a : (x>b?b:x); }

  function gamma01(t, g){ return Math.pow(clamp(t,0,1), g); }
  function gammaSigned(z, g){
    const s = z < 0 ? -1 : 1;
    const a = Math.abs(z);
    return s * Math.pow(clamp(a,0,1), g);
  }

  // RGB helpers
  function hex2rgb(hex){
    const h = hex.replace("#","").trim();
    const n = parseInt(h,16);
    return [(n>>16)&255, (n>>8)&255, n&255];
  }
  function rgb2hex(r,g,b){
    const to = (v)=> v.toString(16).padStart(2,"0");
    return "#" + to(r) + to(g) + to(b);
  }
  function lerp(a,b,t){ return a + (b-a)*t; }
  function lerpRgb(c0,c1,t){
    return [
      Math.round(lerp(c0[0],c1[0],t)),
      Math.round(lerp(c0[1],c1[1],t)),
      Math.round(lerp(c0[2],c1[2],t)),
    ];
  }

  // Palettes (precomputed for speed)
  const C_NEU = hex2rgb("#223554"); // neutral (brighter for contrast)
  const C_D   = hex2rgb("#2f7dff"); // vivid blue
  const C_R   = hex2rgb("#ff3b3b"); // vivid red
  const C_BG  = hex2rgb("#0e1728"); // missing
  const PAL_N = 101;

  function paletteDiverging() {
    // t in [-1,1] => red<0, neutral at 0, blue>0
    const pal = new Array(PAL_N);
    for(let i=0;i<PAL_N;i++){
      const t = (i/(PAL_N-1))*2 - 1;
      if (t < 0){
        const c = lerpRgb(C_NEU, C_R, -t);
        pal[i] = rgb2hex(c[0],c[1],c[2]);
      } else {
        const c = lerpRgb(C_NEU, C_D, t);
        pal[i] = rgb2hex(c[0],c[1],c[2]);
      }
    }
    return pal;
  }

  function paletteSequential(party){
    // t in [0,1] => neutral -> party color
    const to = (party==="D") ? C_D : C_R;
    const pal = new Array(PAL_N);
    for(let i=0;i<PAL_N;i++){
      const t = i/(PAL_N-1);
      const c = lerpRgb(C_NEU, to, t);
      pal[i] = rgb2hex(c[0],c[1],c[2]);
    }
    return pal;
  }

  const PAL_MARGIN = paletteDiverging();
  const PAL_SEQ_D = paletteSequential("D");
  const PAL_SEQ_R = paletteSequential("R");
  const FILL_MISS = rgb2hex(C_BG[0],C_BG[1],C_BG[2]);

  // ---------- App state ----------
  const state = {
    tab: "results",
    svg: null,
    paths: null,
    panzoom: null,
    joinIndex: null,         // Int32Array(paths.length) -> rowIndex or -1
    keyOfPath: null,         // (i)->key
    data: null,              // raw rows
    keyCol: null,
    contests: [],            // contest metadata + typed arrays
    contestKey: null,
    swingFrom: null,
    swingTo: null,
    trendContest: null,
    trendParty: "D",
    trendFrom: null,
    trendTo: null,
    trendChangeParty: "D",
    prevBin: null,
    lastHover: null
  };

  // ---------- DOM refs ----------
  const tabs = Array.from(document.querySelectorAll(".tab"));
  const panelResults = $("#panelResults");
  const panelSwing = $("#panelSwing");
  const panelTrend = $("#panelTrend");
  const panelTrendChange = $("#panelTrendChange");

  const selDataFile = $("#dataFile");
  const selContest = $("#contest");
  const selSwingFrom = $("#swingFrom");
  const selSwingTo = $("#swingTo");
  const selTrendContest = $("#trendContest");
  const selTrendParty = $("#trendParty");
  const selTrendFrom = $("#trendFrom");
  const selTrendTo = $("#trendTo");
  const selTrendChangeParty = $("#trendChangeParty");

  const legendTitle = $("#legendTitle");
  const legendBar = $("#legendBar");
  const legendTicks = $("#legendTicks");
  const tip = $("#tip");

  // ---------- Initialization ----------
  ovClose.onclick = () => hideOverlay();
  ovReload.onclick = () => location.reload();

  if (location.protocol === "file:") {
    showOverlay("Blocked by browser", "You're opening index.html via file://.\n\nBrowsers block fetch() for local files.\nUse GitHub Pages or run a local server:\n  python3 -m http.server 8000\nthen open:\n  http://localhost:8000/", {reload:false, closable:false});
  } else {
    main().catch(err => fatal(err));
  }

  async function main(){
    showOverlay("Loading…", "Starting…");
    await nextFrame();

    setStatus("loading svg…", true);
    const svgUrl = await firstAvailable([
      "./Precincts24G_keyed_simplified.svg",
      "./Precincts24G.svg",
      "./Precincts24G_WGS84/Precincts24G.svg",
    ]);

    if (!svgUrl) throw new Error("SVG not found. Put Precincts24G_keyed_simplified.svg or Precincts24G.svg next to index.html.");

    showOverlay("Loading…", `Fetching SVG:\n${svgUrl}`);
    await nextFrame();
    const svgText = await fetchText(svgUrl);

    showOverlay("Loading…", "Parsing SVG (this can take a few seconds)…");
    await nextFrame();
    const svgEl = parseSvg(svgText);
    svgEl.setAttribute("id","txsvg");
    svgEl.removeAttribute("width");
    svgEl.removeAttribute("height");
    svgEl.style.width = "100%";
    svgEl.style.height = "100%";
    svgEl.style.display = "block";

    const host = $("#mapHost");
    host.replaceChildren(svgEl);
    state.svg = svgEl;

    // Paths
    const paths = svgEl.querySelectorAll("path");
    state.paths = paths;
    state.prevBin = new Int16Array(paths.length);
    state.prevBin.fill(-32768);
    $("#statPaths").textContent = String(paths.length);

    // Key getter (prefer data-pctkey)
    state.keyOfPath = (i) => {
      const p = paths[i];
      return p.getAttribute("data-pctkey") || p.getAttribute("data-PCTKEY") || p.id || "";
    };

    // Setup pan/zoom
    showOverlay("Loading…", "Initializing pan/zoom…");
    await nextFrame();
    state.panzoom = svgPanZoom(svgEl, {
      zoomEnabled: true,
      controlIconsEnabled: false,
      fit: true,
      center: true,
      minZoom: 1,
      maxZoom: 40,
      dblClickZoomEnabled: true,
      mouseWheelZoomEnabled: true,
      preventMouseEventsDefault: true
    });

    // UI wiring
    $("#fitBtn").onclick = () => { state.panzoom.fit(); state.panzoom.center(); };
    $("#resetBtn").onclick = () => { state.panzoom.resetZoom(); state.panzoom.center(); };
    tabs.forEach(t => t.addEventListener("click", () => setTab(t.dataset.tab)));

    selContest.addEventListener("change", () => { state.contestKey = selContest.value; scheduleRender(); });
    selSwingFrom.addEventListener("change", () => { state.swingFrom = selSwingFrom.value; scheduleRender(); });
    selSwingTo.addEventListener("change", () => { state.swingTo = selSwingTo.value; scheduleRender(); });
    selTrendContest.addEventListener("change", () => { state.trendContest = selTrendContest.value; scheduleRender(); });
    selTrendParty.addEventListener("change", () => { state.trendParty = selTrendParty.value; scheduleRender(); });
    selTrendFrom.addEventListener("change", () => { state.trendFrom = selTrendFrom.value; scheduleRender(); });
    selTrendTo.addEventListener("change", () => { state.trendTo = selTrendTo.value; scheduleRender(); });
    selTrendChangeParty.addEventListener("change", () => { state.trendChangeParty = selTrendChangeParty.value; scheduleRender(); });

    // Data file options (auto-detect)
    const dataChoices = [
      {label:"precinct-data-pctkey.csv", url:"./precinct-data-pctkey.csv"},
      {label:"precinct-data-pctkey_auto.csv", url:"./precinct-data-pctkey_auto.csv"},
      {label:"precinct-data.csv", url:"./precinct-data.csv"}
    ];
    for (const ch of dataChoices){
      const opt = document.createElement("option");
      opt.value = ch.url;
      opt.textContent = ch.label;
      selDataFile.appendChild(opt);
    }
    // pick first existing (in order)
    const dataUrl = await firstAvailable(dataChoices.map(x=>x.url));
    selDataFile.value = dataUrl || dataChoices[0].url;
    selDataFile.addEventListener("change", () => loadData(selDataFile.value));

    // Load data
    await loadData(selDataFile.value);

    // Event delegation for hover/click
    svgEl.addEventListener("mousemove", onMove, {passive:true});
    svgEl.addEventListener("mouseleave", () => { hideTip(); clearHover(); }, {passive:true});
    svgEl.addEventListener("click", onClick, {passive:true});

    hideOverlay();
    setStatus("ready", true);
    scheduleRender();
  }

  async function loadData(url){
    setStatus("loading data…", true);
    showOverlay("Loading…", `Fetching CSV:\n${url}`);
    await nextFrame();
    const csvText = await fetchText(url);

    showOverlay("Loading…", "Parsing CSV…");
    await nextFrame();
    const rows = parseCsv(csvText);
    state.data = rows;
    $("#statRows").textContent = String(rows.length);

    // Determine key column
    const cols = rows.columns;
    const keyCol = cols.includes("PCTKEY") ? "PCTKEY" :
                   (cols.includes("pctkey") ? "pctkey" :
                   (cols.includes("GEOID20") ? "GEOID20" : null));
    state.keyCol = keyCol;

    if (!keyCol) throw new Error("CSV missing a key column. Need PCTKEY (preferred) or GEOID20.");

    // Build contest metadata
    const contests = detectContests(cols);
    if (!contests.length) throw new Error("No contests found. Expected columns like E_24_PRES_Dem / _Rep / _Total.");

    // Build typed arrays per contest
    // Also compute statewide totals for trend index.
    showOverlay("Loading…", "Indexing contests…");
    await nextFrame();

    const rowCount = rows.length;
    for (const c of contests){
      c.demArr = new Float64Array(rowCount);
      c.repArr = new Float64Array(rowCount);
      c.totArr = new Float64Array(rowCount);
      let sd=0, sr=0;
      for (let i=0;i<rowCount;i++){
        const r = rows[i];
        const d = +r[c.demCol] || 0;
        const rr = +r[c.repCol] || 0;
        const t = (+r[c.totCol] || (d+rr));
        c.demArr[i]=d;
        c.repArr[i]=rr;
        c.totArr[i]=t;
        sd += d;
        sr += rr;
      }
      const st = sd + sr;
      c.stateDemPct = st>0 ? (sd/st) : 0.5;
      c.stateRepPct = st>0 ? (sr/st) : 0.5;
    }

    state.contests = contests;

    // Fill selects
    fillContestSelect(selContest, contests);
    fillContestSelect(selSwingFrom, contests);
    fillContestSelect(selSwingTo, contests);
    fillContestSelect(selTrendContest, contests);
    fillContestSelect(selTrendFrom, contests);
    fillContestSelect(selTrendTo, contests);

    // Defaults
    state.contestKey = contests[0].key;
    state.swingFrom = contests[0].key;
    state.swingTo = contests[Math.min(1, contests.length-1)].key;
    state.trendContest = contests[0].key;
    state.trendFrom = contests[0].key;
    state.trendTo = contests[Math.min(1, contests.length-1)].key;

    selContest.value = state.contestKey;
    selSwingFrom.value = state.swingFrom;
    selSwingTo.value = state.swingTo;
    selTrendContest.value = state.trendContest;
    selTrendFrom.value = state.trendFrom;
    selTrendTo.value = state.trendTo;

    // Join SVG paths to data rows
    showOverlay("Loading…", "Matching SVG precincts to data…");
    await nextFrame();
    buildJoin();

    hideOverlay();
    setStatus("ready", true);
    scheduleRender();
  }

  function buildJoin(){
    const paths = state.paths;
    const rows = state.data;
    const keyCol = state.keyCol;

    const keyToRow = new Map();
    for (let i=0;i<rows.length;i++){
      const k = String(rows[i][keyCol] ?? "").trim();
      if (!k) continue;
      if (!keyToRow.has(k)) keyToRow.set(k, i);
    }

    const join = new Int32Array(paths.length);
    let matched=0;
    for (let i=0;i<paths.length;i++){
      const k = String(state.keyOfPath(i)).trim();
      const idx = keyToRow.has(k) ? keyToRow.get(k) : -1;
      join[i]=idx;
      if (idx!==-1) matched++;
      if (idx===-1) paths[i].classList.add("miss");
      else paths[i].classList.remove("miss");
    }
    state.joinIndex = join;
    $("#statMatched").textContent = String(matched);
    $("#statUnmatched").textContent = String(paths.length - matched);

    if (matched < Math.floor(paths.length*0.95)) {
      setStatus(`low match (${matched}/${paths.length}) — use precinct-data-pctkey.csv`, false);
    }
  }

  function detectContests(columns){
    const out = [];
    const demCols = columns.filter(c => c.endsWith("_Dem") && c.startsWith("E_"));
    for (const dem of demCols){
      const base = dem.slice(0, -4);
      const rep = base + "_Rep";
      const tot = base + "_Total";
      if (!columns.includes(rep) || !columns.includes(tot)) continue;
      out.push({
        key: base,
        label: prettyContest(base),
        demCol: dem,
        repCol: rep,
        totCol: tot
      });
    }
    out.sort((a,b) => a.key.localeCompare(b.key));
    return out;
  }

  function prettyContest(k){
    const parts = k.split("_");
    if (parts.length >= 3 && parts[0]==="E"){
      const yy = parts[1];
      const year = (yy.length===2 ? ("20"+yy) : yy);
      const race = parts.slice(2).join("_").replaceAll("-", "–");
      return `${year} ${race}`;
    }
    return k;
  }

  function fillContestSelect(sel, contests){
    sel.innerHTML = "";
    for (const c of contests){
      const opt = document.createElement("option");
      opt.value = c.key;
      opt.textContent = c.label;
      sel.appendChild(opt);
    }
  }

  function setTab(tab){
    state.tab = tab;
    tabs.forEach(t => t.classList.toggle("active", t.dataset.tab===tab));
    panelResults.style.display = (tab==="results") ? "" : "none";
    panelSwing.style.display = (tab==="swing") ? "" : "none";
    panelTrend.style.display = (tab==="trend") ? "" : "none";
    panelTrendChange.style.display = (tab==="trendChange") ? "" : "none";
    scheduleRender();
  }

  // ---------- Rendering ----------
  let renderQueued = false;
  function scheduleRender(){
    if (renderQueued) return;
    renderQueued = true;
    requestAnimationFrame(() => {
      renderQueued = false;
      try { render(); }
      catch(err){ fatal(err); }
    });
  }

  function getContest(key){
    return state.contests.find(c => c.key === key) || null;
  }

  function render(){
    if (!state.paths || !state.joinIndex || !state.contests.length) return;

    const tab = state.tab;
    const paths = state.paths;
    const join = state.joinIndex;

    let vmin= -1, vmax= 1;
    let palette = PAL_MARGIN;
    let legend = {title:"Margin", ticks:["R+50","0","D+50"], gradient: gradientCss(PAL_MARGIN)};
    let valueFn = null;

    if (tab === "results"){
      const c = getContest(state.contestKey);
      if (!c) return;
      legend = {title:`Margin · ${c.label}`, ticks:["R+50","0","D+50"], gradient: gradientCss(PAL_MARGIN)};
      valueFn = (rowIdx) => margin(c.demArr[rowIdx], c.repArr[rowIdx]);
      vmin = -0.50; vmax = 0.50;
      palette = PAL_MARGIN;
    } else if (tab === "swing"){
      const c0 = getContest(state.swingFrom);
      const c1 = getContest(state.swingTo);
      if (!c0 || !c1) return;
      legend = {title:`Swing · ${c0.label} → ${c1.label}`, ticks:["R swing","0","D swing"], gradient: gradientCss(PAL_MARGIN)};
      valueFn = (rowIdx) => margin(c1.demArr[rowIdx], c1.repArr[rowIdx]) - margin(c0.demArr[rowIdx], c0.repArr[rowIdx]);
      vmin = -0.25; vmax = 0.25;
      palette = PAL_MARGIN;
    } else if (tab === "trend"){
      const c = getContest(state.trendContest);
      if (!c) return;
      const party = state.trendParty;
      const pal = (party==="D") ? PAL_SEQ_D : PAL_SEQ_R;
      legend = {title:`Trend index · ${party==="D"?"Dem":"Rep"} · ${c.label}`, ticks:["0","50","100"], gradient: gradientCss(pal)};
      valueFn = (rowIdx) => trendIndex(c, rowIdx, party);
      vmin = 0; vmax = 100;
      palette = pal;
    } else if (tab === "trendChange"){
      const c0 = getContest(state.trendFrom);
      const c1 = getContest(state.trendTo);
      if (!c0 || !c1) return;
      const party = state.trendChangeParty;
      legend = {title:`Trend change · ${party==="D"?"Dem":"Rep"} · ${c0.label} → ${c1.label}`, ticks:["shift R","0","shift D"], gradient: gradientCss(PAL_MARGIN)};
      valueFn = (rowIdx) => {
        const d = trendIndex(c1, rowIdx, party) - trendIndex(c0, rowIdx, party);
        return (party==="R") ? -d/50 : d/50;
      };
      vmin = -1; vmax = 1;
      palette = PAL_MARGIN;
    }

    legendTitle.textContent = legend.title;
    legendBar.style.background = legend.gradient;
    legendTicks.innerHTML = legend.ticks.map(t=>`<div>${escapeHtml(t)}</div>`).join("");

    const inv = 1.0 / (vmax - vmin);
    const palN1 = palette.length - 1;
    const prev = state.prevBin;

    let updates = 0;
    for (let i=0;i<paths.length;i++){
      const rowIdx = join[i];
      if (rowIdx === -1){
        if (prev[i] !== -30000){
          paths[i].style.fill = FILL_MISS;
          prev[i] = -30000;
          updates++;
        }
        continue;
      }
      const v = valueFn(rowIdx);
      if (!Number.isFinite(v)){
        if (prev[i] !== -30000){
          paths[i].style.fill = FILL_MISS;
          prev[i] = -30000;
          updates++;
        }
        continue;
      }
      let t = clamp((v - vmin) * inv, 0, 1);
      // Contrast boost: diverging maps around mid; sequential boosts low-end.
      if (palette === PAL_MARGIN) {
        const z = (t * 2) - 1;            // [-1,1]
        const zg = gammaSigned(z, 0.55);  // stronger color near center
        t = (zg + 1) * 0.5;
      } else {
        t = gamma01(t, 0.70);
      }
      const bin = (t * palN1 + 0.5) | 0;
      if (bin !== prev[i]){
        paths[i].style.fill = palette[bin];
        prev[i] = bin;
        updates++;
      }
    }
    setStatus(`ready (${updates} updates)`, true);
  }

  function gradientCss(palette){
    const stops = 12;
    const parts = [];
    for (let i=0;i<=stops;i++){
      const t = i/stops;
      const idx = Math.round(t*(palette.length-1));
      parts.push(`${palette[idx]} ${Math.round(t*100)}%`);
    }
    return `linear-gradient(90deg, ${parts.join(",")})`;
  }

  function margin(d,r){
    const t = d + r;
    return t>0 ? (d - r) / t : 0;
  }

  function trendIndex(contest, rowIdx, party){
    const d = contest.demArr[rowIdx];
    const r = contest.repArr[rowIdx];
    const t = d + r;
    if (t<=0) return NaN;
    const p = (party==="D") ? (d/t) : (r/t);
    const s = (party==="D") ? contest.stateDemPct : contest.stateRepPct;
    if (s<=0) return NaN;
    return 50 * (p / s);
  }

  // ---------- Tooltip / hover ----------
  function onMove(ev){
    const target = ev.target.closest ? ev.target.closest("path") : null;
    if (!target || target.ownerSVGElement !== state.svg) { clearHover(); hideTip(); return; }
    if (state.lastHover !== target){
      clearHover();
      target.classList.add("hover");
      state.lastHover = target;
    }
    const idx = indexOfPath(target);
    if (idx < 0) { hideTip(); return; }
    const rowIdx = state.joinIndex[idx];
    if (rowIdx === -1) { hideTip(); return; }
    const info = buildInfo(rowIdx);
    showTip(ev, info);
  }

  function onClick(ev){ onMove(ev); }

  function indexOfPath(pathEl){
    if (pathEl.__idx !== undefined) return pathEl.__idx;
    const paths = state.paths;
    for (let i=0;i<paths.length;i++){
      if (paths[i] === pathEl) { pathEl.__idx = i; return i; }
    }
    pathEl.__idx = -1;
    return -1;
  }

  function clearHover(){
    if (state.lastHover){
      state.lastHover.classList.remove("hover");
      state.lastHover = null;
    }
  }

  function showTip(ev, info){
    tip.style.left = ev.clientX + "px";
    tip.style.top = ev.clientY + "px";
    tip.innerHTML = info;
    tip.classList.add("show");
  }
  function hideTip(){ tip.classList.remove("show"); }

  function buildInfo(rowIdx){
    const r = state.data[rowIdx];
    const keyCol = state.keyCol;
    const key = String(r[keyCol] ?? "");
    const name = (r.Name !== undefined) ? String(r.Name) : "";

    const tab = state.tab;
    let block = "";
    if (tab==="results"){
      const c = getContest(state.contestKey);
      if (c){
        const d = c.demArr[rowIdx], rr = c.repArr[rowIdx];
        const t = d+rr;
        const m = margin(d, rr);
        block = `<div class="p">${escapeHtml(c.label)}<br><span class="mono">D ${d.toFixed(0)} · R ${rr.toFixed(0)} · margin ${(m*100).toFixed(2)}%</span></div>`;
      }
    } else if (tab==="swing"){
      const c0 = getContest(state.swingFrom), c1 = getContest(state.swingTo);
      if (c0 && c1){
        const sw = margin(c1.demArr[rowIdx], c1.repArr[rowIdx]) - margin(c0.demArr[rowIdx], c0.repArr[rowIdx]);
        block = `<div class="p">${escapeHtml(c0.label)} → ${escapeHtml(c1.label)}<br><span class="mono">margin swing ${(sw*100).toFixed(2)}%</span></div>`;
      }
    } else if (tab==="trend"){
      const c = getContest(state.trendContest);
      if (c){
        const party = state.trendParty;
        const idx = trendIndex(c, rowIdx, party);
        block = `<div class="p">${escapeHtml(c.label)}<br><span class="mono">${party} index ${idx.toFixed(1)}</span></div>`;
      }
    } else if (tab==="trendChange"){
      const c0 = getContest(state.trendFrom), c1 = getContest(state.trendTo);
      if (c0 && c1){
        const party = state.trendChangeParty;
        const idx0 = trendIndex(c0, rowIdx, party);
        const idx1 = trendIndex(c1, rowIdx, party);
        const d = idx1 - idx0;
        block = `<div class="p">${escapeHtml(c0.label)} → ${escapeHtml(c1.label)}<br><span class="mono">${party} index Δ ${d.toFixed(1)}</span></div>`;
      }
    }

    return `
      <div class="h">${escapeHtml(name || "Precinct")}</div>
      <div class="p"><span class="mono">${escapeHtml(keyCol)}=${escapeHtml(key)}</span></div>
      ${block}
    `;
  }

  // ---------- IO ----------
  async function fetchText(url){
    const res = await fetch(url, {cache:"no-store"});
    if (!res.ok) throw new Error(`Fetch failed (${res.status}) for ${url}`);
    return await res.text();
  }

  function parseSvg(svgText){
    const parser = new DOMParser();
    const doc = parser.parseFromString(svgText, "image/svg+xml");
    const svg = doc.querySelector("svg");
    if (!svg) throw new Error("Invalid SVG (no <svg> root).");
    doc.querySelectorAll("script").forEach(n => n.remove());
    return svg;
  }

  function parseCsv(csvText){
    const parsed = Papa.parse(csvText, {header:true, dynamicTyping:true, skipEmptyLines:true});
    if (parsed.errors && parsed.errors.length){
      const e = parsed.errors[0];
      throw new Error(`CSV parse error: ${e.message} at row ${e.row}`);
    }
    const rows = parsed.data;
    rows.columns = parsed.meta.fields || [];
    return rows;
  }

  async function firstAvailable(urls){
    for (const u of urls){
      try{
        const res = await fetch(u, {method:"HEAD", cache:"no-store"});
        if (res.ok) return u;
      } catch(_){ }
    }
    return null;
  }

  function fatal(err){
    console.error(err);
    const msg = (err && err.stack) ? err.stack : String(err);
    showOverlay("Error", msg, {closable:true, reload:true});
    setStatus("error (see overlay)", false);
  }
})();
</script>
</body>
</html>
